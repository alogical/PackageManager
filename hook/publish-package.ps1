param(
    [Parameter(Mandatory = $false)]
    [String]
        $ConfigurationPath
)

###############################################################################
# Environment Configuration
Add-Type -AssemblyName System.IO.Compression.FileSystem

Import-Module PackageManager

$InvocationPath = [System.IO.Path]::GetDirectoryName($MyInvocation.MyCommand.Definition)

# Secure Hashing Algorithm Helper
$sha1 = Get-SecureHashProvider

###############################################################################
# Process Package Content

# Validate Package Configuration Path
if ([String]::IsNullOrEmpty($ConfigurationPath)) {
    $ConfigurationPath = Join-Path $InvocationPath .package-conf.json
}

# Import Package Configuration
$Configuration = ConvertFrom-Json ([String](Get-Content $ConfigurationPath))

# Create Package Archive File & Build Manifest
$ArchivePath = Join-Path $InvocationPath ($Configuration.Name + ".zip")
$archive = [System.IO.Compression.ZipFile]::Open($ArchivePath, 1)
$archive.Dispose()

# Open Archive for Writing
$archive = [System.IO.Compression.ZipFile]::Open($ArchivePath, 2)

$manifest = New-Object System.Collections.ArrayList
$RelativePathExpression = [System.Text.RegularExpressions.Regex]::Escape($Configuration.Root)

# Process Files and Store in Package Archive
foreach ($f in (Get-ChildItem $Configuration.Root -File -Recurse)) {
    $skip = $false

    # Ignore Autogenerated Archive File
    if ($f.FullName -eq $ArchivePath) {
        continue
    }

    # Check Ignore List
    foreach ($regex in $Configuration.Ignore) {
        if ($f.Name -match $regex) {
            $skip = $true
            break
        }
    }

    # Ignore File
    if ($skip) {
        continue
    }

    # Process File
    $file = [PSCustomObject]@{
        Path = ($f.FullName -replace $RelativePathExpression, [String]::Empty)
        SHA1 = $sha1.HashFile($f)
    }
    [void]$manifest.Add($file)
    Add-ArchiveEntry -Path $f.FullName -EntryPath $file.Path -Archive $archive
}

# Close Archive File
$archive.Dispose()

$repository = ConvertFrom-Json ([String](Get-Content $Configuration.Repository))

# Build Package Object
$params = @{
    Name = $Configuration.Name
    SHA1 = $sha1.HashFile( (Get-Item -LiteralPath $ArchivePath) )
    Version = $Configuration.Version
    Install = "& .\install.ps1"
    Uninstall = [string]::Empty
    Path = Join-Path (Split-Path $Configuration.Repository -Parent) (Split-Path $ArchivePath -Leaf)
    Source = $repository.Name
    Repository = $repository.Name
    Manifest = $manifest
    Dependency = $Configuration.Dependency
}
$package = New-Package @params

# Register Package with Repository
if (Register-Package $package $repository.Path) {
    Move-Item $ArchivePath (Split-Path $Configuration.repository -Parent) -Force
}
else {
    Write-Error "Package registration failed."
    Remove-Item $ArchivePath
}